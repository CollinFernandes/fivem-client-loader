"use strict"; var __create = Object.create; var __defProp = Object.defineProperty; var __getOwnPropDesc = Object.getOwnPropertyDescriptor; var __getOwnPropNames = Object.getOwnPropertyNames; var __getProtoOf = Object.getPrototypeOf; var __hasOwnProp = Object.prototype.hasOwnProperty; var __copyProps = (to, from, except, desc) => { if (from && typeof from === "object" || typeof from === "function") { for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable }) } return to }; var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod)); var import_fs = __toESM(require("fs"), 1); var import_path = __toESM(require("path"), 1); var Loader = class { constructor() { this.resourceDir = GetResourcePath(GetCurrentResourceName()); this.rootPath = this.resourceDir; this.resourceName = GetCurrentResourceName(); this.privateKeys = []; this.clientScripts = []; this.clientConfigs = []; this.publicKey = "eTrsWztKYrDv69cRJ47f2QTbLsJV9R2eeF6vkxtSVBjrHCKuk7hSQ8QTudWmx5GaxXQCNdhxfujDxJmmyGSCCZus8mnYprdt8CPZWZHm4pGyvGgyQ3vJByCnbfExZA5AQqazXr4fgwdVHuzNupGUgXHNf3Rg4pQmEbBPuTPSTTqXdmW6uxCUjNDs9whw2jf4px6yESDkA7vmAu3jzUXL3vGFHJ53HcK2pDAvLAyqmKDyY25pmV34fHu83rXg8WUPD8sjh4LMsR4MWKzmEGDquGnCc2Bk2q2rPDYfGRHwfTbDtVqCeSBqZjq7C3xLLjjBqjs4JrC7jdQDYPZDq7M9ffq4ASgSpDmwHFmQfjXUKN9g4FecTngbAsCyW6xkar2GDJeWAT3M3HPRvJNA7H4k2DcJm2ftdM82yUwmqgfXfXhdsKF9bjzHFWftXj6JYsJwaS8zEGzA9w5v6LwUkxhfmkzbBUpgw3YWzzwJu3TUUYUTv3ENBVVFJNFdqPKQvQh6" } readFileContent(filePath) { try { return (0, import_fs.readFileSync)(filePath, "utf8") } catch (err) { return null } } extractParentFolder(filePath) { const components = filePath.split(import_path.default.sep); return components.length >= 2 ? components[components.length - 2] : null } getFilesInDirectory(rootPath) { return import_fs.default.readdirSync(rootPath, { withFileTypes: true }) } loadFilesRecursively(directory) { const files = this.getFilesInDirectory(directory); const fileList = []; files.forEach(file => { const filePath = import_path.default.join(directory, file.name); if (file.isDirectory()) { this.loadFilesRecursively(filePath) } else if (file.isFile()) { const fileName = import_path.default.basename(filePath); const key = this.extractParentFolder(filePath); const content = this.readFileContent(filePath); if (key && content) { fileList.push({ name: fileName, content }) } } }); return fileList } loadScripts(files, type, key, src) { files.map((file, index) => { const encoded = exports[this.resourceName].XOREncode(file.content, key); TriggerClientEvent("clientLoader:receiveScript", src, file.name, index, encoded, type); setTimeout(() => { }, 100) }) } async sendScripts(source2, key) { await this.loadScripts(this.clientConfigs, "config", key, source2); await setTimeout(() => { }, 100); await this.loadScripts(this.clientScripts, "script", key, source2) } async registerEvents() { onNet("clientLoader:requestKey", () => { const src = source; const key = exports[this.resourceName].randomString(512); this.privateKeys[src] = key; TriggerClientEvent("clientLoader:receiveKey", src, exports[this.resourceName].XOREncode(key, this.publicKey)); setTimeout(async () => { await this.sendScripts(src, key) }, 250) }) } async setup() { this.clientScripts = this.loadFilesRecursively(import_path.default.join(this.rootPath, "client/code")); this.clientConfigs = this.loadFilesRecursively(import_path.default.join(this.rootPath, "client/configs")); await this.registerEvents() } }; var loader = new Loader; loader.setup();
